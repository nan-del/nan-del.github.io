<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="逆向笔记">
<meta property="og:url" content="http://example.com/2021/07/21/%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/07/22/hkyqB3fw8l1St5b.png">
<meta property="og:image" content="https://i.loli.net/2021/07/26/W5NvJ7sx9T1XnBV.png">
<meta property="og:image" content="https://i.loli.net/2021/07/26/qNuFnfKWlkOmsZw.png">
<meta property="og:image" content="https://i.loli.net/2021/07/27/1ovzE5rXRA3ZkTf.png">
<meta property="og:image" content="https://i.loli.net/2021/07/31/raqTviWXzERIlup.png">
<meta property="og:image" content="https://i.loli.net/2021/07/31/ui3SeQkGNCsnmwF.png">
<meta property="og:image" content="https://i.loli.net/2021/07/31/ghGrHLxK15XNZDB.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/2PubKmwnqW54BlU.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/eAgcjPLt9hUpm2r.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/czslw7BFyfZxjHS.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/R8vflZL29QBjSgJ.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/wtBxiNGFkAS5ZUR.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/uqZv7QjpwbAV9PU.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/yBKhe4sw25TOlJ8.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/ZGydgKcIleMjSD7.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/02/KQlNyEhUw3ajMvz.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/02/AEXfnRygxa5pkCv.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/02/LPxfXK1FV6cRp3G.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/02/TMmbwzfpjxaA75K.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/02/NQGL72fiOs43l6R.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/02/SEh2WBeUTJPdji7.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/02/JKCt3u8ASyUXZd6.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/02/2HJcrTgNMDPfZn6.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/02/9tdhiySDpog8wRG.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/09/7FKPkXoDBxNezIn.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/10/SHKW1GBrubRC4X3.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/10/25g1jpetLHlEFuk.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/10/BgIAFMvWQyV2Y4e.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/09/U4Pc9ufb6SWVhlk.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/18/euicmLOCt3AndwJ.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/18/KimW539SYguVLxA.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/18/iIPu4DAVas5YNpr.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/18/fuQRLazgeTb9r7c.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/18/TFORJGu2HD1Iweh.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/18/caO9kHCinEt4mQp.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/18/BpvDLkjuUncOATW.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/18/98yhOBG1ZKu3sEF.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/18/EqpX2UTnermd3F9.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/18/XvhxmgsGboU7cTa.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/18/yzJSxlt7nQEToqw.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/18/UblLzHokmcXOvDu.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/26/6kfYOLQ8Zrz3H7g.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/26/R9ymw5lTjoOnA36.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/26/X2PLyWhFgGiuEqx.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/26/kcPbjAua46CoILB.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/26/fQ6GkKpw18C7Nre.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/26/WeasIkrDnMFtKCG.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/26/AMWIUudzRKBlmH9.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/26/M8UNoAxRX7Cs6n1.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/26/glcpyd9BFzIYbhS.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/26/R1OEpB8liag7zbm.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/11/h4DojrH9nkvOXlf.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/12/BVsF1XkTrG9o458.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/12/RYC49zIQb7XSqtO.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/12/UrHOdfPBGx1IuaA.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/12/E8M7ICLzms3AnWl.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/12/csReTUFpWwzPQXg.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/12/kn6qsHRfJUc75Pd.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/12/B8uDpXy9tC6mwIP.png">
<meta property="og:image" content="https://s2.loli.net/2022/02/27/wKOjJnhaL6BTgDG.png">
<meta property="og:image" content="https://s2.loli.net/2022/02/27/K1Zc5HpDb7JfC9U.png">
<meta property="og:image" content="https://s2.loli.net/2022/02/27/Lg6dGZzubjCxPDQ.png">
<meta property="og:image" content="https://s2.loli.net/2022/03/09/Csc29d6H74aAVwR.png">
<meta property="og:image" content="https://s2.loli.net/2022/03/09/47a5UsYqPlnSZyk.png">
<meta property="og:image" content="https://s2.loli.net/2022/02/28/J9yeBzW24E5iRdp.png">
<meta property="og:image" content="https://s2.loli.net/2022/02/28/o5udli2Hnxyms9N.png">
<meta property="og:image" content="https://s2.loli.net/2022/02/28/kcxVSYuI6KETFsv.png">
<meta property="og:image" content="https://s2.loli.net/2022/02/28/HIAS6dB8b5cap7Q.png">
<meta property="article:published_time" content="2021-07-21T11:23:15.000Z">
<meta property="article:modified_time" content="2022-03-09T04:59:34.081Z">
<meta property="article:author" content="nan-del">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/07/22/hkyqB3fw8l1St5b.png">

<link rel="canonical" href="http://example.com/2021/07/21/%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>逆向笔记 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/21/%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nan-del">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          逆向笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-21 19:23:15" itemprop="dateCreated datePublished" datetime="2021-07-21T19:23:15+08:00">2021-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-09 12:59:34" itemprop="dateModified" datetime="2022-03-09T12:59:34+08:00">2022-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><escape><span id="more"></span></escape></p>
<h1 id="BUUCTF题目"><a href="#BUUCTF题目" class="headerlink" title="BUUCTF题目"></a>BUUCTF题目</h1><h2 id="OD快捷键"><a href="#OD快捷键" class="headerlink" title="OD快捷键"></a>OD快捷键</h2><p>F2：设置断点、只要在光标定位的位置按F2键即可，再按一次F2键则会删除断点</p>
<p>F8：单步步过，每按一次这个键执行一次反汇编窗口中的一条指令，遇到call等子程序不进入其代码</p>
<p>F7：单步步入，功能同单步步过（F8）类似，区别是遇到call等子程序会进入其中，进入后首先会停留在子程序的第一条指令上</p>
<p>F4：运行到选定职位，作用就是直接运行到光标所在的位置处暂停</p>
<p>F9：运行，按下这个键如果没有设置相应断点的话，被调试的程序将直接开始运行</p>
<p>ctrl + F9：执行到返回，此命令在执行到一个ret(返回指令)指令时暂时，常用于从系统部分返回到我们调试的程序部分</p>
<h2 id="常用断点之INT3断点原理解析"><a href="#常用断点之INT3断点原理解析" class="headerlink" title="常用断点之INT3断点原理解析"></a>常用断点之INT3断点原理解析</h2><p>INT3断点其实就是F2断点，也可以叫做CC断点</p>
<p>原理：</p>
<ol>
<li>按下F2后，OD会替换指令，也就是把原来的指令替换为int3指令</li>
<li>OD检测到int3指令后会引发一个异常并且捕获它，这时候程序就会中断</li>
<li>删除断点后，OD会删除int3指令，并且还原之前的代码</li>
</ol>
<p>优点：可以无限的下int3断点</p>
<p>缺点：很容易被检测</p>
<h2 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h2><p>链接地址：<a target="_blank" rel="noopener" href="https://buuoj.cn/challenges#easyre">https://buuoj.cn/challenges#easyre</a></p>
<p>解析：</p>
<p>使用IDA直接打开，按下<code>shitf+F12</code> 就可以直接看到flag了，这比较简单，只是入门题目。</p>
<p><img src="https://i.loli.net/2021/07/22/hkyqB3fw8l1St5b.png" alt="image-20210722205342946"></p>
<h2 id="reverse1"><a href="#reverse1" class="headerlink" title="reverse1"></a>reverse1</h2><p>解析：</p>
<ol>
<li>使用IDA打开exe文件</li>
<li>按下<code>shift + F12</code>,找到关键字符</li>
</ol>
<p><img src="https://i.loli.net/2021/07/26/W5NvJ7sx9T1XnBV.png" alt="image-20210726210554251"></p>
<ol start="3">
<li>点击进入‘this is the right flag!\n’</li>
<li>得到‘aThisIsTheRight’这个变量，我们把光标放到这个变量上并右键，点击<code>Jump to xref to operand</code> 就可以到使用这个变量的函数哪里，这样才能使用<code>tab</code>键进行反汇编，看到代码。</li>
</ol>
<p><img src="https://i.loli.net/2021/07/26/qNuFnfKWlkOmsZw.png" alt="image-20210726210803828"></p>
<ol start="5">
<li><p>得到代码后，就可以分析了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">  #</span><span class="bash"> 首先了解两个函数：j_strlen 、 strncmp</span> </span><br><span class="line">  </span><br><span class="line"><span class="meta">  #</span><span class="bash"> j_strlen是测字符串的长度的，但不包括‘\0<span class="string">&#x27;。</span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="string"> strncmp函数为字符串比较函数，字符串大小的比较是以ASCII 码表上的顺序来决定，此顺序亦为字符的值。其函数声明为int strncmp ( const char * str1, const char * str2, size_t n );功能是把 str1 和 str2 进行比较，最多比较前 n 个字节，若str1与str2的前n个字符相同，则返回0；若s1大于s2，则返回大于0的值；若s1 小于s2，则返回小于0的值。</span></span></span><br><span class="line">  </span><br><span class="line">  char v5[36]; // [rsp+0h] [rbp-20h] BYREF</span><br><span class="line">  int j; // [rsp+24h] [rbp+4h]</span><br><span class="line">  char Str1[224]; // [rsp+48h] [rbp+28h] BYREF</span><br><span class="line">  unsigned __int64 v8; // [rsp+128h] [rbp+108h]</span><br><span class="line"></span><br><span class="line">  v0 = v5;</span><br><span class="line">  for ( i = 82i64; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v0 = -858993460;</span><br><span class="line">    v0 += 4;</span><br><span class="line">  &#125;</span><br><span class="line">  for ( j = 0; ; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = j;</span><br><span class="line">    v2 = j_strlen(Str2);   # 这里是得到str2字符串的长度再循环</span><br><span class="line">    if ( v8 &gt; v2 )</span><br><span class="line">      break;</span><br><span class="line">    if ( Str2[j] == 111 )  # 111和48这里是ascii码，分别代表o和0，其实就是当str2中有o时，用0代替。</span><br><span class="line">      Str2[j] = 48;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_1400111D1(&quot;input the flag:&quot;);</span><br><span class="line">  sub_14001128F(&quot;%20s&quot;, Str1);</span><br><span class="line">  v3 = j_strlen(Str2);</span><br><span class="line">  if ( !strncmp(Str1, Str2, v3) ) # 这里是字符串的比较，如果ste1和str2相同，就打印下面的字符串，不同，就执行else</span><br><span class="line">    sub_1400111D1(&quot;this is the right flag!\n&quot;);</span><br><span class="line">  else</span><br><span class="line">    sub_1400111D1(&quot;wrong flag\n&quot;);</span><br><span class="line">  sub_14001113B(v5, &amp;unk_140019D00);</span><br><span class="line">  return 0i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>现在就是等到str2的值了，我们可以直接点击str2就可以转到定义它的位置。</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/07/27/1ovzE5rXRA3ZkTf.png" alt="image-20210727204501638"></p>
<p>​    7. 所以得到的flag是：{hell0_w0rld}</p>
<h2 id="reverse2"><a href="#reverse2" class="headerlink" title="reverse2"></a>reverse2</h2><p>解析：</p>
<ol>
<li>使用IDA打开reverse_2文件</li>
</ol>
<p><img src="https://i.loli.net/2021/07/31/raqTviWXzERIlup.png" alt="image-20210729220314114"></p>
<ol start="2">
<li>点击<code>this is the right flag!</code>进入</li>
</ol>
<p><img src="https://i.loli.net/2021/07/31/ui3SeQkGNCsnmwF.png" alt="image-20210729220445024"></p>
<ol start="3">
<li>跳转到使用这个变量的地方得到反汇编后的代码</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们只用关注重要的代码和重要的函数</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 有些函数在上一个的例子中有解释，这里就不解释了</span></span><br><span class="line"></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line">  int stat_loc; // [rsp+4h] [rbp-3Ch] BYREF</span><br><span class="line">  int i; // [rsp+8h] [rbp-38h]</span><br><span class="line">  __pid_t pid; // [rsp+Ch] [rbp-34h]</span><br><span class="line">  char s2[24]; // [rsp+10h] [rbp-30h] BYREF</span><br><span class="line">  unsigned __int64 v8; // [rsp+28h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(0x28u);</span><br><span class="line">  pid = fork();</span><br><span class="line">  if ( pid )</span><br><span class="line">  &#123;</span><br><span class="line">    waitpid(pid, &amp;stat_loc, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= strlen(&amp;flag); ++i )   </span><br><span class="line">    &#123;</span><br><span class="line">      if ( *(&amp;flag + i) == 105 || *(&amp;flag + i) == 114 )   # 105代表i;114代表r</span><br><span class="line">        *(&amp;flag + i) = 49;  # 49代表数字1    这两行就是把flag中的r和i 替代为 1  ,所以需要找到flag代表什么</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;input the flag:&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%20s&quot;, s2);  # 这一步是s2是输入时的变量，即到时候使用s2与改变之后的falg作比较</span><br><span class="line">  if ( !strcmp(&amp;flag, s2) ) #这一步就是使用输入的s2与变量flag比较，相同则是正确的flag，即改变之后的flag就是这道题目的flag</span><br><span class="line">    result = puts(&quot;this is the right flag!&quot;);</span><br><span class="line">  else</span><br><span class="line">    result = puts(&quot;wrong flag!&quot;);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>找到变量flag的值，即flag为：{hacking_for_fun}</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000601080 flag            db 7Bh                  ; DATA XREF: main+34↑r  # 7Bh转化为ascii码为123，即 flag            db  &#123; </span><br><span class="line">.data:0000000000601080                                         ; main+44↑r ...</span><br><span class="line">.data:0000000000601081 aHackingForFun  db &#x27;hacking_for_fun&#125;&#x27;,0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结合下面的`hacking_for_fun&#125;`就是：`&#123;hacking_for_fun&#125;`</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/07/31/ghGrHLxK15XNZDB.png" alt="image-20210729221551408"></p>
<ol start="5">
<li>然后把r和i 替换为1即flag为：<code>flag&#123;hack1ng_fo1_fun&#125;</code></li>
</ol>
<h2 id="新年快乐"><a href="#新年快乐" class="headerlink" title="新年快乐"></a>新年快乐</h2><p>解析：</p>
<ol>
<li>首先判断这个exe是多少位的程序。</li>
</ol>
<p>使用记事本打开这个exe程序，如果第二行的PE后面是<code>L</code>就是32位的程序，如果是<code>d</code>就是64为的程序。</p>
<p><img src="https://i.loli.net/2021/11/14/2PubKmwnqW54BlU.png" alt="image-20211114172054966"></p>
<ol start="2">
<li>使用32位的IDA打开这个exe程序，结果有加壳的警告：</li>
</ol>
<p><img src="https://i.loli.net/2021/11/14/eAgcjPLt9hUpm2r.png" alt="image-20211114172343072"></p>
<ol start="3">
<li>所以我们可以使用PEiD查看这个exe程序被加了UPX的壳</li>
</ol>
<p><img src="https://i.loli.net/2021/11/14/czslw7BFyfZxjHS.png" alt="image-20211114173242107"></p>
<ol start="4">
<li>接着使用去壳工具把壳去掉，这个<code>新年快乐_unpacked.exe</code>就是去壳后的程序</li>
</ol>
<p><img src="https://i.loli.net/2021/11/14/R8vflZL29QBjSgJ.png" alt="image-20211114173623291"></p>
<p><img src="https://i.loli.net/2021/11/14/wtBxiNGFkAS5ZUR.png" alt="image-20211114173654218"></p>
<ol start="5">
<li>我们在使用32位的IDA打开</li>
</ol>
<p><img src="https://i.loli.net/2021/11/14/uqZv7QjpwbAV9PU.png" alt="image-20211114174007875"></p>
<p><img src="https://i.loli.net/2021/11/14/yBKhe4sw25TOlJ8.png" alt="image-20211114174056657"></p>
<p>最后得到代码：</p>
<p><img src="https://i.loli.net/2021/11/14/ZGydgKcIleMjSD7.png" alt="image-20211114174212991"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> Str2[<span class="number">14</span>]; <span class="comment">// [esp+12h] [ebp-3Ah] BYREF</span></span><br><span class="line">  __int16 Str1; <span class="comment">// [esp+20h] [ebp-2Ch] BYREF</span></span><br><span class="line">  _BYTE v6[<span class="number">30</span>]; <span class="comment">// [esp+22h] [ebp-2Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_401910();</span><br><span class="line">  <span class="built_in">strcpy</span>(Str2, <span class="string">&quot;HappyNewYear!&quot;</span>);</span><br><span class="line">  Str1 = word_40306B;</span><br><span class="line">  <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="keyword">sizeof</span>(v6));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;please input the true flag:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;Str1);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;Str1, Str2, <span class="built_in">strlen</span>(Str2)) )</span><br><span class="line">    result = <span class="built_in">puts</span>(aThisIsTrueFlag);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(Buffer);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>最后分析当Str1等于Str2的时候，会输出<code>aThisIsTrueFlag</code>，而 <code>aThisIsTrueFlag</code> 就是 <code>this is true flag!</code>, 所以flag= <code>HappyNewYear!</code>。</li>
</ol>
<h1 id="反调试技巧"><a href="#反调试技巧" class="headerlink" title="反调试技巧"></a>反调试技巧</h1><h2 id="隐藏字符串"><a href="#隐藏字符串" class="headerlink" title="隐藏字符串"></a>隐藏字符串</h2><p>当我们使用IDA或者OD的时候，一般都会搜索字符串来查看是否有一些重要的信息透露，所以我们可以使用隐藏字符串来阻碍一些新手小白进行调试。</p>
<p>我们可以使用二进制来替换一些关键字符，避免被搜索到，这里就先介绍一下OD和IDA搜索字符串的原理吧（可能会不正确，这是目前我的看法，以后学的知识多了，可能会再调整）</p>
<h4 id="OD搜索字符串的原理"><a href="#OD搜索字符串的原理" class="headerlink" title="OD搜索字符串的原理"></a>OD搜索字符串的原理</h4><p>OD搜索字符串的都是使用插件的，而插件的代码原理是：循环判断汇编指令中是否有push、mov、lea这几个指令，假如有push ebp这个汇编指令，就看这个ebp这个地址的二进制是不是一个字符串。判断ebp是否是字符串就只是判断否是是以<code>\0</code>结尾的，所以OD搜索出来的都是以<code>\0</code>结尾的字符串，所以我们可以使用一些结构体或者在重要字符串前面加上<code>\0</code>结尾来隐藏字符串也可以使用二进制代替字符。</p>
<p>但是尽管是使用使用二进制代替字符来隐藏字符串，如果你的这个变量是全局变量的话，在OD中依然可以使用字符串搜索出来。如果使用局部变量就搜索不出来。原因是：<code>全局变量会被编译器编译在.data中形成字符串</code>，所以即使是使用使用二进制代替字符来隐藏字符串也必须是局部变量。</p>
<p>接下来举一个简单的例子：</p>
<p><strong>全局变量的例子</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">## 这是全局变量的例子</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[] = &#123;<span class="number">0xd7</span>,<span class="number">0xa2</span>,<span class="number">0xb2</span>,<span class="number">0xe1</span>,<span class="number">0xca</span>,<span class="number">0xa7</span>,<span class="number">0xb0</span>,<span class="number">0xdc</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> oo [] = &#123;<span class="number">0xC4</span>,<span class="number">0xE3</span>,<span class="number">0xBA</span>,<span class="number">0xC3</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(str);</span><br><span class="line">	<span class="built_in">printf</span>(oo);</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/01/02/KQlNyEhUw3ajMvz.png" alt="image-20220102222757935"></p>
<p>点击进来，进入main函数</p>
<p><img src="https://s2.loli.net/2022/01/02/AEXfnRygxa5pkCv.png" alt="image-20220102223028789"></p>
<p>这是str变量的地址：0xF95000</p>
<p><img src="https://s2.loli.net/2022/01/02/LPxfXK1FV6cRp3G.png" alt="image-20220102223116399"></p>
<p>这是oo变量的地址：0xF9500C</p>
<p><img src="https://s2.loli.net/2022/01/02/TMmbwzfpjxaA75K.png" alt="image-20220102223246813"></p>
<p>然后我们在内存中查看：0xF95000地址的位置</p>
<p><img src="https://s2.loli.net/2022/01/02/NQGL72fiOs43l6R.png" alt="image-20220102223433771"></p>
<p>点击进去，就可以看到这两个字符串了</p>
<p><img src="https://s2.loli.net/2022/01/02/SEh2WBeUTJPdji7.png" alt="image-20220102223536959"></p>
<p><strong>局部变量的例子</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">## 这是局部变量的例子</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str[] = &#123;<span class="number">0xd7</span>,<span class="number">0xa2</span>,<span class="number">0xb2</span>,<span class="number">0xe1</span>,<span class="number">0xca</span>,<span class="number">0xa7</span>,<span class="number">0xb0</span>,<span class="number">0xdc</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> oo [] = &#123;<span class="number">0xC4</span>,<span class="number">0xE3</span>,<span class="number">0xBA</span>,<span class="number">0xC3</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(str);</span><br><span class="line">	<span class="built_in">printf</span>(oo);</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到没有搜索出来字符串，除了<code>pause</code>之外。但是虽然使用字符串搜索插件不能找出字符串，但是我们可以在<strong>内存中搜索</strong></p>
<p><img src="https://s2.loli.net/2022/01/02/JKCt3u8ASyUXZd6.png" alt="image-20220102223930132"></p>
<p>这是’注册失败’的位置</p>
<p><img src="https://s2.loli.net/2022/01/02/2HJcrTgNMDPfZn6.png" alt="image-20220102224216413"></p>
<p>这是’你好’的位置，还可以看到’注册失败’</p>
<p><img src="https://s2.loli.net/2022/01/02/9tdhiySDpog8wRG.png" alt="image-20220102224339749"></p>
<h4 id="IDA搜索字符串的原理"><a href="#IDA搜索字符串的原理" class="headerlink" title="IDA搜索字符串的原理"></a>IDA搜索字符串的原理</h4><p>IDA是静态分析工具，所以不会说什么内存中搜索，IDA搜索字符串的原理是把PE文件的字符串读取出来，只要是在PE文件头中可以搜索出来的，在IDA中都可以搜索出来。所以我们可以使用二进制来代替字符串，这样在PE文件头就不会搜索出来字符串了。</p>
<h1 id="逆向技巧"><a href="#逆向技巧" class="headerlink" title="逆向技巧"></a>逆向技巧</h1><ol>
<li>当汇编代码中有<code>local1</code>、<code>local2</code>等这样的，都是函数中的局部变量</li>
<li>在IDA中转到特定的地址，直接按G就可以了</li>
<li>dll劫持：加载dll的时候会采用就近原则，如果在同一文件夹内就会优先加载同一文件夹下的dll，而不会在系统文件夹中加载dll，这就是dll劫持。但是有一个问题，那就是假如需要用到dll怎么办呢？这就有另一个技术，叫API转发，就是当程序调用到真正的dll的时候，会用劫持dll转发出去，到系统的dll中，这样劫持dll就起到一个桥梁的作用。</li>
<li>怎么判断是否程序有加壳：</li>
</ol>
<p>加壳的程序使用OD调试的时候，如果没有运行起来，看到的汇编代码是看不懂的，因为壳把真正的代码都隐藏了起来，真正代码位置地址的汇编代码可能都是00，只有运行起来的时候，才会把原来对应地址上的代码吐出来</p>
<ul>
<li>OD提示：在使用OD加载程序的时候，如果有弹出有加壳、加密等的信息，都是有加壳的程序</li>
<li>所以第二方法就是查看代码段的地址是否在运行的时候会改变</li>
</ul>
<ol start="5">
<li>有壳的软件怎么写劫持补丁：</li>
</ol>
<ul>
<li>HOOK API（还不会，但是可行）</li>
<li>就是循环判断 ，等到壳把真实的代码吐出来之后才可以把补丁打上去，否则在壳把真实的代码吐出来之前打上去的补丁是没有效果的</li>
</ul>
<ol start="6">
<li>什么是EIP：EIP是一个寄存器，用来指向下一句要执行的代码的位置</li>
<li>进程和线程的概念：</li>
</ol>
<p>32位有4GB，64位有16EB   (G 、TB、PB 、EB)</p>
<p>进程是死的，是不会运行的，进程和线程之间的关系是：宿主与寄宿者的关系，即线程需要进程提供资源</p>
<p>线程上下文：CONTEXT用于线程之间的切换  </p>
<ol start="8">
<li>seh：是指编程时所用到的 try catch；而veh：是指  ；系统在查找程序异常的时候是先找veh在找seh的，所以veh的优先级是高于seh的</li>
<li>CRC检测：CRC，中文名称为循环冗余校验，CRC属于密码学一类算法，常用于数据校验，一般会用来检测程序是否被脱壳或者被修改，以达到防破解的目的。主要是检测是否有下断点</li>
</ol>
<p>过CRC检测通常的方法：</p>
<ul>
<li>挂起CRC检测的线程</li>
<li>干掉CRC检测的判断（这个简单的还好，复杂的有难度）</li>
<li>绕过CRC检测的位置，到更底层去改</li>
<li>硬件HOOK</li>
<li>其他HOOK，欺骗CRC检测函数（虚表HOOK）</li>
<li>干掉退出函数</li>
</ul>
<p>简单打防CRC检测代码示例：</p>
<p>这样只有在代码节中有下断点，程序就会停止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即把.text节中的所有字节加起来，如果没有改变就说明没有被调试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反调试-cc断点.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gTotal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(_In_ LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> byteToal = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> address = <span class="number">0x00401000</span>;  <span class="comment">//这是PE中的.text代码段的起始地址（也只有在代码断中被下断点是会结束的）</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; <span class="number">0x2000</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			byte byteRead = <span class="number">0</span>;</span><br><span class="line">			ReadProcessMemory((HANDLE)<span class="number">-1</span>,(LPCVOID)address,&amp;byteRead,<span class="number">1</span>,<span class="literal">NULL</span>);</span><br><span class="line">			byteToal += byteRead;</span><br><span class="line">			address++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,byteToal);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,gTotal);</span><br><span class="line">		<span class="keyword">if</span>(byteToal != gTotal) <span class="comment">//这是判断一开始读到的和开辟出来的线程作比较，如果相同就是没有改变，这个改变可能就是被下断点</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;结束\n&quot;</span>);  <span class="comment">//这里就是可能有人在调试我们的程序，我们可以做一个蓝屏（虽然有点过分）</span></span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		byteToal = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> address = <span class="number">0x00401000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; <span class="number">0x2000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		byte byteRead = <span class="number">0</span>;</span><br><span class="line">		ReadProcessMemory((HANDLE)<span class="number">-1</span>,(LPCVOID)address,&amp;byteRead,<span class="number">1</span>,<span class="literal">NULL</span>);</span><br><span class="line">		gTotal += byteRead;</span><br><span class="line">		address++;</span><br><span class="line">	&#125;</span><br><span class="line">	CreateThread(<span class="literal">NULL</span>,<span class="literal">NULL</span>,ThreadProc,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);   <span class="comment">//这是创建一个线程用来循环判断程序是是否被更改</span></span><br><span class="line">	</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/01/09/7FKPkXoDBxNezIn.png" alt="image-20220109165231942"></p>
<p>这是vs2010中改变基址的地方，只有当程序中的基址和代码中的基址一样的时候，才会生效，如果是随机基址，就很大可能不生效</p>
<ol start="10">
<li>硬件断点的原理：通过对地址调试寄存器写值构造异常中断，然后调试器接管（DR0-DR7,其中DR7最重要）</li>
</ol>
<p>在OD中需要点击<code>查看调试寄存器</code>才能看到这些寄存器</p>
<p><img src="https://s2.loli.net/2022/01/10/SHKW1GBrubRC4X3.png" alt="image-20220110184103845"></p>
<p>其中第10位是<code>1</code>，这一为即使设置为1也是无效的。</p>
<p><img src="https://s2.loli.net/2022/01/10/25g1jpetLHlEFuk.png" alt="image-20220110184744347"></p>
<p><img src="https://s2.loli.net/2022/01/10/BgIAFMvWQyV2Y4e.png" alt="image-20220110201224775"></p>
<p> 这张图中的GR0-DR3是地址调试寄存器，这是存我们的地址的。DR4-DR5是保留的。DR6是调试状态寄存器，DR7是调试控制寄存器。DR7决定着DR0-DR3是否生效。如果<code>0 2 4 6</code>这4个置为1，那么就说明DR0-DR3有效，而G0-G3和L0-L3的区别在于一个会自动清除，一个不会自动清除。（但是这个G的位置，目前来说好像是有问题的，即G0为1时，其他都为0，这个硬件断点是断不下来的，至于为什么，不清楚）</p>
<ol start="11">
<li>上面有个简单的CRC检测，这里有两个简单的方法可以绕过这个检测：</li>
</ol>
<p>一：这里可以看到，上面这个检测的CRC程序有一个进程的时间一直在增加，即CPU一直有在分配时间片给这个进程，所以我们可以把这个进程给挂起，这样那个一直循环检测的就会失效，这样我们在下断点，就不会出事了</p>
<p><img src="https://s2.loli.net/2022/01/09/U4Pc9ufb6SWVhlk.png" alt="image-20220109205328542"></p>
<p>二：我们虽然不可以下CC断点，但是我们可以下硬件断点，这样就可以不用修改代码，就可以使程序断下来了</p>
<ol start="12">
<li>在代码节开始的位置，如果是有字符串比较的话，我们可以直接搜索<code>test edx,3</code>(这是易语言中的字符串比较)</li>
<li>ctrl+G的插件的bug：当下硬件断点时，我们需要重新启动一遍程序才可以成功。解决方法：我们可以把插件中的<code>IDAFicator.dll</code>从文件中移掉，这样我们下了硬件断点之后就不用重启程序了</li>
<li>加壳是保护PE文件的，VM是保护代码的。加VM的话是只保护当前函数的代码，即在当前函数加VM，而其它函数是没有加VM的。如<code>VMProtect.3.2 破解版</code>加VM是在对应地址的函数上加VM。加壳是保护PE文件，这只是不能修改程序的代码，即不能NOP掉关键位置，是可以在OD中看到代码的，而且我们可以用打内存补丁的方法破解程序</li>
<li>壳加载的过程：</li>
</ol>
<ul>
<li>运行程序</li>
<li>在内存中吐出我们的代码</li>
<li>转到真实的OEP</li>
<li>执行真实的代码</li>
<li>执行到我们想要下断点的位置</li>
</ul>
<p>所以我们想要执行到我们下断点的位置，我们就要在执行真实的代码之后到执行我们想要下断点的位置之间让程序断下来。如果有窗体程序，我们可以在CreateWindowExA下断点</p>
<ol start="16">
<li>花指令的作用：主要是防止静态分析的，即IDA，但是花指令并不会影响程序的执行    </li>
</ol>
<p><img src="https://s2.loli.net/2022/01/18/euicmLOCt3AndwJ.png" alt="image-20220118210610391"></p>
<p><img src="https://s2.loli.net/2022/01/18/KimW539SYguVLxA.png" alt="image-20220118210654077"></p>
<p><img src="https://s2.loli.net/2022/01/18/iIPu4DAVas5YNpr.png" alt="image-20220118210815924"></p>
<p><img src="https://s2.loli.net/2022/01/18/fuQRLazgeTb9r7c.png" alt="image-20220118210846251"></p>
<p><img src="https://s2.loli.net/2022/01/18/TFORJGu2HD1Iweh.png" alt="image-20220118210907559"></p>
<p><img src="https://s2.loli.net/2022/01/18/caO9kHCinEt4mQp.png" alt="image-20220118211112726"></p>
<p><img src="https://s2.loli.net/2022/01/18/BpvDLkjuUncOATW.png" alt="image-20220118211231892"></p>
<p><img src="https://s2.loli.net/2022/01/18/98yhOBG1ZKu3sEF.png" alt="image-20220118211440920"></p>
<p><img src="https://s2.loli.net/2022/01/18/EqpX2UTnermd3F9.png" alt="image-20220118211531123"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_asm </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">xor</span> eax,eax  # 这是将eax清零</span><br><span class="line">		test eax,eax	# 这是判断eax是否为<span class="number">0</span>,如果为<span class="number">0</span>就可以跳转，不为<span class="number">0</span>就执行下面的语句，但是上面已经将eax清零，所以这是绝对跳转</span><br><span class="line">		je Lebel1</span><br><span class="line">		_emit <span class="number">0e8</span>h</span><br><span class="line">		Lebel1:</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Test Junk Code&quot;</span>);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成上面的代码后拖进OD查看，会发现搜索不到字符串</p>
<p><img src="https://s2.loli.net/2022/01/18/XvhxmgsGboU7cTa.png" alt="image-20220118212812690"></p>
<p><img src="https://s2.loli.net/2022/01/18/yzJSxlt7nQEToqw.png" alt="image-20220118214719187"></p>
<p><img src="https://s2.loli.net/2022/01/18/UblLzHokmcXOvDu.png" alt="image-20220118220334445"></p>
<p><img src="https://s2.loli.net/2022/01/26/6kfYOLQ8Zrz3H7g.png" alt="image-20220126202455246"></p>
<p><img src="https://s2.loli.net/2022/01/26/R9ymw5lTjoOnA36.png" alt="image-20220126202557247"></p>
<p>可以看到这里的语句是红色的，使用F5也没有反应。就是使用花指令生效了，</p>
<p><img src="https://s2.loli.net/2022/01/26/X2PLyWhFgGiuEqx.png" alt="image-20220126204130583"></p>
<p><img src="https://s2.loli.net/2022/01/26/kcPbjAua46CoILB.png" alt="image-20220126204249991"></p>
<p>删除分析之后，可以看到这个中间已经断了。花指令的构造思路就是构造恒成立的跳转，在代码中间插入无效代码，所以花指令可以防止静态分析但是很难防止动态分析也可以防止字符串搜索</p>
<p>补充：</p>
<p><img src="https://s2.loli.net/2022/01/26/fQ6GkKpw18C7Nre.png" alt="image-20220126211716144"></p>
<p>这个可以在VS中关闭这个call</p>
<p><img src="https://s2.loli.net/2022/01/26/WeasIkrDnMFtKCG.png" alt="image-20220126212050277"></p>
<p><img src="https://s2.loli.net/2022/01/26/AMWIUudzRKBlmH9.png" alt="image-20220126212237897"></p>
<p>手动去除花指令：去除花指令可以把中间的无效代码NOP掉。如上面的程序就是把004010BF NOP掉（而下面的图是因为重新生成了，所以地址变得不一样）</p>
<p><img src="https://s2.loli.net/2022/01/26/M8UNoAxRX7Cs6n1.png" alt="image-20220126214940359"></p>
<p><img src="https://s2.loli.net/2022/01/26/glcpyd9BFzIYbhS.png" alt="image-20220126215456877"></p>
<p><img src="https://s2.loli.net/2022/01/26/R1OEpB8liag7zbm.png" alt="image-20220126215431790"></p>
<h1 id="PE"><a href="#PE" class="headerlink" title="PE"></a>PE</h1><p>可执行文件指的是可以由操作系统进行加载的文件</p>
<p>可执行文件的格式：</p>
<p>​    Windows平台：PE文件结构</p>
<p>​    Linux平台：ELF文件结构 </p>
<p>可执行文件都遵守PE文件结构：</p>
<p>​    前两个字节是<code>MZ</code>，而且在第四行即3C的位置的值，然后再找到相应的位置，如果是PE那么就是这个文件就是PE文件。这个也叫PE指纹。</p>
<p>即使文件不是以exe、dll、sys等常规文件后缀命名，只要是PE格式，都是可以被执行的。</p>
<p><img src="https://s2.loli.net/2022/01/11/h4DojrH9nkvOXlf.png" alt="image-20220111205011536"></p>
<ol>
<li>DOS部分：是历史的遗留问题，主要是给DOS用的</li>
<li>PE文件头：主要是Windows用的</li>
<li>节表：是存放的是节数据中的开始和结束部位，还有内容</li>
<li>节数据：是真正这个文件存储的内容</li>
</ol>
<p>.text节是存放代码的；.data节是存放全局变量的；.rsrc节是存放只读数据的</p>
<p>确定字节的部分：</p>
<p>“PE”,0,0(4个字节)：PE文件头的标志</p>
<p>IMAGE_DOS_HEADER(64个字节)                                      IMAGE_FILE_HEADER(20个字节，标准PE头)</p>
<p>IMAGE_OPTIONAL_HEADER32(224个字节，这个32位和64位的大小是不一样的，而且这个大小还可以被修改，扩展PE头)    </p>
<p>IMAGE_SECTION_HEADER(40个字节)                                            </p>
<p>不确定字节的部分：</p>
<p>DOS Stub ：这一块的数据是给链接器用的，链接器会在这里插入自己的数据，所以大小是不确定的，那么怎么找这一部分的数据呢？</p>
<p>IMAGE_DOS_HEADER结构中最后4个字节是表示PE文件头的开始部分，即在PE文件头的开始到DOS部分的前64个字节就是DOS Stub的部分</p>
<p><img src="https://s2.loli.net/2022/01/12/BVsF1XkTrG9o458.png" alt="image-20220112201601326"></p>
<p>PE文件头可以分为三个部分：</p>
<ol>
<li>“PE”,0,0 ：PE文件头标志（PE标识不能破坏，操作系统在启动一个程序的时候会检测这个标识，同样的，MZ标志也会检测 ）</li>
<li>IMAGE_FILE_HEADER结构体：标准PE头</li>
<li>IMAGE_OPTIONAL_HEADER32结构体：扩展PE头</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/12/RYC49zIQb7XSqtO.png" alt="image-20220112203158547"></p>
<p>其中扩展PE头里有一个变量是：SizeOfHeaders，这是存储DOS头+PE头+所有节表的大小，按照文件对齐以后的大小，按照文件对齐是因为执行的时候效率更高（是扩展PE头第60个字节的后的4个字节，也在文件对齐后的第20个字节）</p>
<p>其中扩展PE头里有一个变量是：FileAlignment，这是文件对齐的大小（是扩展PE头第36个字节的后的4个字节）</p>
<p>SizeOfHeaders的值一定是FileAlignment的整数倍</p>
<p>其中，PE扩展还存储了内存对齐值的大小，就在文件对齐的前四个字节</p>
<p><img src="https://s2.loli.net/2022/01/12/UrHOdfPBGx1IuaA.png" alt="image-20220112210503240"></p>
<p><img src="https://s2.loli.net/2022/01/12/E8M7ICLzms3AnWl.png" alt="image-20220112210630650"></p>
<p><img src="https://s2.loli.net/2022/01/12/csReTUFpWwzPQXg.png" alt="image-20220112210927980"></p>
<h2 id="标准PE头"><a href="#标准PE头" class="headerlink" title="标准PE头"></a>标准PE头</h2><p><img src="https://s2.loli.net/2022/01/12/kn6qsHRfJUc75Pd.png" alt="image-20220112220137500"></p>
<p>下面就是标准PE头里的Characteristics的属性</p>
<p><img src="https://s2.loli.net/2022/01/12/B8uDpXy9tC6mwIP.png" alt="image-20220112221550706"></p>
<p>例子：将32位的notepad.exe拖入winhex观察Characteristics的属性</p>
<p><img src="https://s2.loli.net/2022/02/27/wKOjJnhaL6BTgDG.png" alt="image-20220227164908160"></p>
<p>可以看到是0102也就是0000 0001 0000 0010 在Characteristics的属性分别是：文件是可执行的和只在32位平台上运行</p>
<h2 id="扩展PE头"><a href="#扩展PE头" class="headerlink" title="扩展PE头"></a>扩展PE头</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大小: 32bit(0xE0) 64bit(0xF0)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    WORD    Magic;                         (重要) <span class="comment">//文件类型: 10Bh为32位PE文件 / 20Bh为64位PE文件</span></span><br><span class="line">    BYTE    MajorLinkerVersion;             <span class="comment">//链接器(主)版本号 对执行没有任何影响</span></span><br><span class="line">    BYTE    MinorLinkerVersion;             <span class="comment">//链接器(次)版本号 对执行没有任何影响</span></span><br><span class="line">    DWORD   SizeOfCode;                     <span class="comment">//包含代码的节的总大小.文件对齐后的大小.编译器填的没用</span></span><br><span class="line">    DWORD   SizeOfInitializedData;          <span class="comment">//包含已初始化数据的节的总大小.文件对齐后的大小.编译器填的没用.</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;        <span class="comment">//包含未初始化数据的节的总大小.文件对齐后的大小.编译器填的没用.(未初始化数据,在文件中不占用空间;但在被加载到内存后,PE加载程序会为这些数据分配适当大小的虚拟地址空间).</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;            (重要)<span class="comment">//程序入口(RVA)</span></span><br><span class="line">    DWORD   BaseOfCode;                     <span class="comment">//代码的节的基址(RVA).编译器填的没用(代码节起始的RVA,表示映像被加载进内存时代码节的开头相对于ImageBase的偏移地址,节的名称通常为&quot;.text&quot;)</span></span><br><span class="line">    DWORD   BaseOfData;                     <span class="comment">//数据的节的基址(RVA).编译器填的没用(数据节起始的RVA,表示映像被加载进内存时数据节的开头相对于ImageBase的偏移地址,节的名称通常为&quot;.data&quot;)</span></span><br><span class="line">    DWORD   ImageBase;                      (重要)<span class="comment">//内存镜像基址</span></span><br><span class="line">    DWORD   SectionAlignment;               (重要)<span class="comment">//内存对齐大小</span></span><br><span class="line">    DWORD   FileAlignment;                  (重要)<span class="comment">//文件对齐大小</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion;    <span class="comment">//标识操作系统主版本号 </span></span><br><span class="line">    WORD    MinorOperatingSystemVersion;    <span class="comment">//标识操作系统次版本号 </span></span><br><span class="line">    WORD    MajorImageVersion;              <span class="comment">//PE文件自身的主版本号</span></span><br><span class="line">    WORD    MinorImageVersion;              <span class="comment">//PE文件自身的次版本号</span></span><br><span class="line">    WORD    MajorSubsystemVersion;          <span class="comment">//运行所需子系统主版本号</span></span><br><span class="line">    WORD    MinorSubsystemVersion;          <span class="comment">//运行所需子系统次版本号</span></span><br><span class="line">    DWORD   Win32VersionValue;              <span class="comment">//子系统版本的值.必须为0,否则程序运行失败.</span></span><br><span class="line">    DWORD   SizeOfImage;                    (重要)<span class="comment">//内存中整个PE文件的映射尺寸.可比实际的值大.必须是SectionAlignment的整数倍</span></span><br><span class="line">    DWORD   SizeOfHeaders;                  (重要)<span class="comment">//所有头+节表按照文件对齐后的大小.</span></span><br><span class="line">    DWORD   CheckSum;                       (重要)<span class="comment">//校验和.大多数PE文件该值为0.在内核模式的驱动程序和系统DLL中,该值则是必须存在且是正确的.在IMAGEHLP.DLL中函数CheckSumMappedFile就是用来计算文件头校验和的,对于整个PE文件也有一个校验函数MapFileAndCheckSum.</span></span><br><span class="line">    WORD    Subsystem;                      <span class="comment">//文件子系统  驱动程序(1) 图形界面(2) 控制台/DLL(3)</span></span><br><span class="line">    WORD    DllCharacteristics;             <span class="comment">//文件特性.不是针对DLL文件的</span></span><br><span class="line">    DWORD   SizeOfStackReserve;             <span class="comment">//初始化时保留的栈大小.该字段默认值为0x100000(1MB),如果调用API函数CreateThread时,堆栈参数大小传入NULL,则创建出来的栈大小将是1MB.</span></span><br><span class="line">    DWORD   SizeOfStackCommit;              <span class="comment">//初始化时实际提交的栈大小.保证初始线程的栈实际占用内存空间的大小,它是被系统提交的.这些提交的栈不存在与交换文件里,而是在内存中.</span></span><br><span class="line">    DWORD   SizeOfHeapReserve;              <span class="comment">//初始化时保留的堆大小.用来保留给初始进程堆使用的虚拟内存,这个堆的句柄可以通过调用函数GetProcessHeap获得.每一个进程至少会有一个默认的进程堆,该堆在进程启动时被创建,而且在进程的生命期中不会被删除.默认值为1MB.</span></span><br><span class="line">    DWORD   SizeOfHeapCommit;               <span class="comment">//初始化时实践提交的堆大小.在进程初始化时设定的堆所占用的内存空间,默认值为PAGE_SIZE. </span></span><br><span class="line">    DWORD   LoaderFlags;                    <span class="comment">//调试相关</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes;            <span class="comment">//目录项数目,默认为10h.</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];<span class="comment">//结构数组 数组元素个数由IMAGE_NUMBEROF_DIRECTORY_ENTRIES定义</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, * PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<p>Magic    这个是判断程序是多少为的程序的标识</p>
<p>AddressOfEntryPoint    这个是程序的入口（但是这个需要加下面的ImageBase的值，才是真正的程序运行起来后的地址，这个可以说是偏移，是PE中执行代码的地方，这个是扩展PE头后面的16个字节后的位置）</p>
<p>ImageBase    内存镜像基址（就是程序运行起来后，在内存中加载的地址，这个是AddressOfEntryPoint的位置后再往后8个字节的位置）</p>
<p>例子：这个是自己之前生成的一个exe程序，可以看到AddressOfEntryPoint + ImageBase就是真正的程序的入口</p>
<p><img src="https://s2.loli.net/2022/02/27/K1Zc5HpDb7JfC9U.png" alt="image-20220227175837706"></p>
<p>SizeOfImage    内存中整个PE文件的映射尺寸.可比实际的值大.必须是SectionAlignment（内存对齐的大小）的整数倍</p>
<p>SizeOfHeaders    所有头+节表按照文件对齐后的大小（这个一定是文件对齐大小的整数倍）</p>
<p>不管是文件对齐还是内存对齐，PE头都是不会展开的，他们之间是没有空隙的，只是后面的节数据之间和PE头和第一个节数据之间有空隙。</p>
<p>CheckSum    校验和，用来判断文件是否被修改，大多数PE文件该值为0.在内核模式的驱动程序和系统DLL中,该值则是必须存在且是正确的.在IMAGEHLP.DLL中函数CheckSumMappedFile就是用来计算文件头校验和的,对于整个PE文件也有一个校验函数MapFileAndCheckSum.（<strong>这个值是从PE一开始的地方两个字节、两个字节相加，从头加到尾的结果在加文件的长度的值就是校验和的值</strong>）</p>
<p>DllCharacteristics    下面的图就是DllCharacteristics有的属性，是两个字节</p>
<p><img src="https://s2.loli.net/2022/02/27/Lg6dGZzubjCxPDQ.png" alt="image-20220227185734276"></p>
<h2 id="RVA与FOA的转换"><a href="#RVA与FOA的转换" class="headerlink" title="RVA与FOA的转换"></a>RVA与FOA的转换</h2><p>一个全局变量如果有初始值，那么这个全局变量就会在PE文件中有地址，它的值一定是存储在PE文件中的。如果一个全局变量没有初始值，那么PE文件中就没有这个全局变量的位置，只有这个文件加载到内存中的时候才会给这个全局变量分配空间。</p>
<p><strong>RVA    相对虚拟地址（即实际运行的地址 - ImageBase的值 ）</strong></p>
<p><strong>FOA    文件偏移地址</strong></p>
<p>RVA与FOA转换的步骤：</p>
<ol>
<li>判断RVA是否在头部，在的话直接就是FOA = RVA</li>
<li>判断RVA在哪一个节的数据中</li>
</ol>
<p>RVA  &gt;=  节.VirtualAddress（）</p>
<p>RVA  &lt;=  节.VirtualAddress  +  当前节内存对齐后的大小</p>
<p>差值  =  RVA  -  节.VirtualAddress（这个是当前节在内存中从那个地址展开）</p>
<pre><code>3. FOA  =  节.PointerToRawData（这个是当前节在文件中从那个地址展开）
</code></pre>
<p>示例：在win32程序中插入一段代码，并执行。以下列的程序<code>注册判断.exe</code>为例，在注册判断.exe中插入一个MessageBoxA的弹窗</p>
<p><img src="https://s2.loli.net/2022/03/09/Csc29d6H74aAVwR.png" alt="image-20220309123940892"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHELLCODELENGTH  0x12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MESSAGEBOXA      0x75830380    <span class="comment">//这是MessageBoxA的地址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILENAME     <span class="meta-string">&quot;D:/vs2010文件/随意的项目/内存复制/Project2/Debug/注册判断.exe&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEW_FILENAME     <span class="meta-string">&quot;D:/vs2010文件/随意的项目/内存复制/Project2/Debug/注册判断_new.exe&quot;</span></span></span><br><span class="line"></span><br><span class="line">BYTE shellcode[] =        <span class="comment">//这是MessageBoxA的硬编码</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">0x6A</span>,<span class="number">00</span>,<span class="number">0x6A</span>,<span class="number">00</span>,<span class="number">0x6A</span>,<span class="number">00</span>,<span class="number">0x6A</span>,<span class="number">00</span>,</span><br><span class="line">	<span class="number">0xE8</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,</span><br><span class="line">	<span class="number">0xE9</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">file_get_contents</span><span class="params">(<span class="keyword">char</span>* filename)</span></span>;</span><br><span class="line"><span class="function">DWORD <span class="title">Copy</span><span class="params">(VOID* pFileBuffer)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">Write</span><span class="params">(VOID* pFileBuffer, <span class="keyword">char</span>* filename,<span class="keyword">int</span> length)</span></span>;</span><br><span class="line">VOID* pFileBuffer = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;----------------Begin---------------&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	length = file_get_contents(FILENAME);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p:%p\n&quot;</span>, pFileBuffer);</span><br><span class="line">	Copy(pFileBuffer);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;----------------End-----------------&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">file_get_contents</span><span class="params">(<span class="keyword">char</span>* filename )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LPVOID pTempFileBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD length = <span class="number">0</span>;</span><br><span class="line">	FILE* fp = fopen(filename, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;The file can not be opened.&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">	length = ftell(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;文件的大小：%d\n&quot;</span>, length);</span><br><span class="line">	fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">	</span><br><span class="line">	pTempFileBuffer = <span class="built_in">malloc</span>(length);</span><br><span class="line">	<span class="keyword">if</span> (!pTempFileBuffer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;分配空间失败！！！\n&quot;</span>);</span><br><span class="line">		fclose(fp);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;分配空间成功\n&quot;</span>);</span><br><span class="line">	<span class="keyword">size_t</span> n = fread(pTempFileBuffer, length, <span class="number">1</span>, fp);</span><br><span class="line">	<span class="keyword">if</span> (!n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;读取失败！！！\n&quot;</span>);</span><br><span class="line">		<span class="built_in">free</span>(pTempFileBuffer);</span><br><span class="line">		fclose(fp);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;读取成功\n&quot;</span>);</span><br><span class="line">	pFileBuffer = pTempFileBuffer;</span><br><span class="line">	pTempFileBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="keyword">return</span> length;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">Copy</span><span class="params">(VOID* pFileBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIMAGE_DOS_HEADER pDosHeader = <span class="literal">NULL</span>;</span><br><span class="line">	PIMAGE_NT_HEADERS pNtHeader = <span class="literal">NULL</span>;</span><br><span class="line">	PIMAGE_FILE_HEADER pPEHeader = <span class="literal">NULL</span>;</span><br><span class="line">	PIMAGE_OPTIONAL_HEADER32 pOptionHeader = <span class="literal">NULL</span>;</span><br><span class="line">	PIMAGE_SECTION_HEADER pSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">	WORD a = <span class="number">0</span>;</span><br><span class="line">	DWORD ImageBase = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span>* name= <span class="literal">NULL</span>;</span><br><span class="line">	DWORD VirtualSize = <span class="number">0</span> ;</span><br><span class="line">	DWORD OEP = <span class="number">0</span>;</span><br><span class="line">	DWORD codeaddr = <span class="number">0</span>;</span><br><span class="line">	DWORD addr1 = <span class="number">0</span>;</span><br><span class="line">	DWORD addr2 = <span class="number">0</span>;</span><br><span class="line">	VOID* pTempFileBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD addr = <span class="number">0</span>;</span><br><span class="line">	DWORD E8_codeaddr = <span class="number">0</span>;</span><br><span class="line">	DWORD E9_codeaddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	pTempFileBuffer = <span class="built_in">malloc</span>(length);</span><br><span class="line">	pTempFileBuffer = pFileBuffer;</span><br><span class="line">	addr = pTempFileBuffer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*((PWORD)pTempFileBuffer) != IMAGE_DOS_SIGNATURE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;!!!这不是有效的PE格式\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;这是一个PE格式的文件\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer;</span><br><span class="line">	<span class="keyword">if</span> (*((PWORD)((DWORD)pFileBuffer + pDosHeader-&gt;e_lfanew)) != IMAGE_NT_SIGNATURE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;不是有效的PE标识\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;这是有效的PE标识\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	pNtHeader = (PIMAGE_NT_HEADERS)((DWORD)pFileBuffer + pDosHeader-&gt;e_lfanew);</span><br><span class="line">	pPEHeader = (PIMAGE_FILE_HEADER)(((DWORD)pNtHeader) + <span class="number">4</span>);</span><br><span class="line">	a = pPEHeader-&gt;SizeOfOptionalHeader;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a:%d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">	pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + IMAGE_SIZEOF_FILE_HEADER);</span><br><span class="line">	ImageBase = pOptionHeader-&gt;ImageBase;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ImageBase:%d\n&quot;</span>, ImageBase);</span><br><span class="line"></span><br><span class="line">	pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);</span><br><span class="line">	name = pSectionHeader-&gt;Name;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;name: %s\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">	VirtualSize = pSectionHeader-&gt;Misc.VirtualSize;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Mise: %d\n&quot;</span>, VirtualSize);</span><br><span class="line"></span><br><span class="line">	OEP = pOptionHeader-&gt;AddressOfEntryPoint;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;EOP: %d\n&quot;</span>, OEP);</span><br><span class="line"></span><br><span class="line">	codeaddr = VirtualSize + <span class="number">0xC</span> + pSectionHeader-&gt;PointerToRawData + addr;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;codeaddr: %d\n&quot;</span>, codeaddr);</span><br><span class="line">	<span class="built_in">memcpy</span>(codeaddr, shellcode, SHELLCODELENGTH);</span><br><span class="line"></span><br><span class="line">	E8_codeaddr = ImageBase+ VirtualSize + <span class="number">0xC</span> + pSectionHeader-&gt;VirtualAddress + <span class="number">0x8</span> ;</span><br><span class="line"></span><br><span class="line">	addr1 = MESSAGEBOXA - E8_codeaddr - <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;addr1: %d\n&quot;</span>, addr1);</span><br><span class="line">	*(PDWORD)(codeaddr + <span class="number">9</span>) = addr1;</span><br><span class="line"></span><br><span class="line">	E9_codeaddr = ImageBase + VirtualSize + <span class="number">0xC</span> + pSectionHeader-&gt;VirtualAddress + <span class="number">0xD</span>;</span><br><span class="line"></span><br><span class="line">	addr2 = ImageBase + OEP  - E9_codeaddr - <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;addr2: %d\n&quot;</span>, addr2);</span><br><span class="line">	*(PDWORD)(codeaddr + <span class="number">0xE</span>) = addr2;</span><br><span class="line"></span><br><span class="line">	pOptionHeader-&gt;AddressOfEntryPoint = E8_codeaddr - ImageBase - <span class="number">0x8</span>;</span><br><span class="line"></span><br><span class="line">	Write(pFileBuffer, NEW_FILENAME, length);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;生成结束！！！\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Write</span><span class="params">(VOID* pFileBuffer, <span class="keyword">char</span>* filename, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE* fp = <span class="literal">NULL</span>;</span><br><span class="line">	fp = fopen(filename, <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;写入失败！！！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	fwrite(pFileBuffer, length, <span class="number">1</span>, fp);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/03/09/47a5UsYqPlnSZyk.png" alt="image-20220309125416178"></p>
<p>以上代码的关键点就是RVA与FOA的转换，就是计算出OEP，代码在内存中运行的地址，还有E8,E9后面的两个地址的值</p>
<ol>
<li>首先在代码节找到足够的内存存放我们的shellcode，并计算出存放代码地址的开头位置在内存中的RVabA</li>
<li>把原始的OEP改为我们想让他开始运行的地址</li>
<li>计算E8后面的值，就是MessageBoxA在内存中的地址，这个后面可以在导入表中找出，这里就先是使用OD找出的地址</li>
<li>计算E9后面的值，就是执行完我们的shellcode后直接跳到原始的OEP去，执行原来的程序</li>
</ol>
<h2 id="扩大节"><a href="#扩大节" class="headerlink" title="扩大节"></a>扩大节</h2><p>节表从开头到结束一共40个字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节表的数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span>&#123;</span></span><br><span class="line">BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">// 8个字节的节区名称，当前节的名字</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  DWORD PhysicalAddress;       </span><br><span class="line">  DWORD VirtualSize;            <span class="comment">//Misc双字是改节在没有对齐前的真实尺寸，该值可以不准确</span></span><br><span class="line">&#125;Misc;</span><br><span class="line">DWORD VirtualAddress;         <span class="comment">// 节区的 RVA 地址，在内存中的偏移地址，加上ImageBase才是在内存中的真正地址</span></span><br><span class="line">DWORD SizeOfRawData;            <span class="comment">// 节在文件中对齐后的尺寸</span></span><br><span class="line">DWORD PointerToRawData;        <span class="comment">// 节在文件中的偏移量，即在文件中开始的地址</span></span><br><span class="line">DWORD PointerToRelocations;     <span class="comment">// 在OBJ文件中使用，重定位的偏移</span></span><br><span class="line">DWORD PointerToLinenumbers;   <span class="comment">// 行号表的偏移（供调试使用地）</span></span><br><span class="line">WORD NumberOfRelocations;      <span class="comment">// 在OBJ文件中使用，重定位项数目</span></span><br><span class="line">WORD NumberOfLinenumbers;    <span class="comment">// 行号表中行号的数目</span></span><br><span class="line">DWORD Characteristics;       <span class="comment">// 节属性如可读，可写，可执行等</span></span><br><span class="line">&#125;IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER</span><br></pre></td></tr></table></figure>

<p>扩大节的步骤：</p>
<ol>
<li>分配一块新的空间，大小为S，即在PE的最后一个节后面添加00字符，这个大小随意，需要扩大多少就添加多少</li>
<li>将最后一个节的SizeOfRawData和VirtualSize改为N</li>
</ol>
<p>N = (SizeOfRawData或者VirtualSize内存对齐后的值)(其实就是哪一个大就用哪一个) + S</p>
<ol start="3">
<li>修改SizeOfImage的大小（这是扩展PE头里面的参数）</li>
</ol>
<p>例子：</p>
<p>在注册判断.exe中扩大0x1000（即4096个字节）</p>
<ol>
<li>在文件尾部添加4096个字节</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/28/J9yeBzW24E5iRdp.png" alt="image-20220228212337222"></p>
<p><img src="https://s2.loli.net/2022/02/28/o5udli2Hnxyms9N.png" alt="image-20220228212421660"></p>
<ol start="2">
<li>找出SizeOfRawData和VirtualSize的值，判断哪一个大，就用哪一个与我们要扩大的值相加</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/28/kcxVSYuI6KETFsv.png" alt="image-20220228213244194"></p>
<ol start="3">
<li>然后就是修改SizeOfRawData和VirtualSize的值，改成相同的大小</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/28/HIAS6dB8b5cap7Q.png" alt="image-20220228213540035"></p>
<ol start="4">
<li>修改SizeOfImage的大小</li>
<li>修改Characteristics的属性，是可读、可写、还是可执行</li>
</ol>
<p>这里有点问题，我做了完整的步骤但是最后这个exe执行不了，但是我只是添加字节，不修改内容是可以运行的，所以下面的步骤先不贴出来，解决之后再说吧</p>
<h2 id="新增节"><a href="#新增节" class="headerlink" title="新增节"></a>新增节</h2><p>新增节的步骤：</p>
<ol>
<li>判断是否有足够的空间，可以添加一个节表</li>
<li>在节表中新增一个成员</li>
<li>修改PE头中节的数量</li>
<li>修改SizeOfImage的大小</li>
<li>在原有数据的最后，新增一个节的数据（内存对齐的整数倍）</li>
<li>修正新增节表的属性</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/21/Leetcode%E7%AC%94%E8%AE%B0/Leetcode%E7%AC%94%E8%AE%B0/" rel="prev" title="Leetcode笔记">
      <i class="fa fa-chevron-left"></i> Leetcode笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/03/%E5%90%8E%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/%E5%90%8E%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/" rel="next" title="后渗透学习">
      后渗透学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#BUUCTF%E9%A2%98%E7%9B%AE"><span class="nav-number">1.</span> <span class="nav-text">BUUCTF题目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#OD%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="nav-number">1.1.</span> <span class="nav-text">OD快捷键</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%AD%E7%82%B9%E4%B9%8BINT3%E6%96%AD%E7%82%B9%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="nav-number">1.2.</span> <span class="nav-text">常用断点之INT3断点原理解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#easyre"><span class="nav-number">1.3.</span> <span class="nav-text">easyre</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reverse1"><span class="nav-number">1.4.</span> <span class="nav-text">reverse1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reverse2"><span class="nav-number">1.5.</span> <span class="nav-text">reverse2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90"><span class="nav-number">1.6.</span> <span class="nav-text">新年快乐</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">2.</span> <span class="nav-text">反调试技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.1.</span> <span class="nav-text">隐藏字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OD%E6%90%9C%E7%B4%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.0.1.</span> <span class="nav-text">OD搜索字符串的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IDA%E6%90%9C%E7%B4%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.0.2.</span> <span class="nav-text">IDA搜索字符串的原理</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%86%E5%90%91%E6%8A%80%E5%B7%A7"><span class="nav-number">3.</span> <span class="nav-text">逆向技巧</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PE"><span class="nav-number">4.</span> <span class="nav-text">PE</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E5%87%86PE%E5%A4%B4"><span class="nav-number">4.1.</span> <span class="nav-text">标准PE头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95PE%E5%A4%B4"><span class="nav-number">4.2.</span> <span class="nav-text">扩展PE头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RVA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.3.</span> <span class="nav-text">RVA与FOA的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%A4%A7%E8%8A%82"><span class="nav-number">4.4.</span> <span class="nav-text">扩大节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E8%8A%82"><span class="nav-number">4.5.</span> <span class="nav-text">新增节</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">nan-del</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nan-del</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
